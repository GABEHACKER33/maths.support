<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maths Support - Gaming Platform</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŽ®</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Manrope:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Supabase SDK -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a28;
            --accent-primary: #00ff88;
            --accent-secondary: #00ccff;
            --accent-danger: #ff4466;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b8;
            --border-color: rgba(255, 255, 255, 0.08);
            --shadow-glow: 0 0 40px rgba(0, 255, 136, 0.15);
        }

        body {
            font-family: 'Manrope', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            inset: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(0, 255, 136, 0.03), transparent 40%),
                radial-gradient(circle at 80% 70%, rgba(0, 204, 255, 0.03), transparent 40%);
            pointer-events: none;
            z-index: 0;
        }

        #root {
            position: relative;
            z-index: 1;
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-primary);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent-secondary);
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Supabase Configuration - REPLACE WITH YOUR CONFIG
        const SUPABASE_CONFIG = {
            url: 'YOUR_SUPABASE_URL',
            anonKey: 'YOUR_SUPABASE_ANON_KEY'
        };

        // Initialize Supabase
        let supabase = null;
        try {
            supabase = window.supabase.createClient(SUPABASE_CONFIG.url, SUPABASE_CONFIG.anonKey);
        } catch (error) {
            console.error('Failed to initialize Supabase:', error);
        }

        // Games Data
        const GAMES = [
            { id: '1', title: 'Drive Mad', category: 'Racing', url: 'https://games.playtropolis.com/drive-mad-v2/', thumbnail: 'https://images.unsplash.com/photo-1511919884226-fd3cad34687c?w=400&h=300&fit=crop', color: '#ff4466' },
            { id: '2', title: 'Subway Surfers', category: 'Endless Runner', url: 'https://poki.com/en/g/subway-surfers', thumbnail: 'https://images.unsplash.com/photo-1550745165-9bc0b252726f?w=400&h=300&fit=crop', color: '#00ccff' },
            { id: '3', title: 'Tetris', category: 'Puzzle', url: 'https://tetris.com/play-tetris', thumbnail: 'https://images.unsplash.com/photo-1607853202273-797f1c22a38e?w=400&h=300&fit=crop', color: '#00ff88' },
            { id: '4', title: 'Snake', category: 'Arcade', url: 'https://playsnake.org/', thumbnail: 'https://images.unsplash.com/photo-1511512578047-dfb367046420?w=400&h=300&fit=crop', color: '#ffaa00' },
            { id: '5', title: 'Chess', category: 'Strategy', url: 'https://www.chess.com/play/computer', thumbnail: 'https://images.unsplash.com/photo-1529699211952-734e80c4d42b?w=400&h=300&fit=crop', color: '#8844ff' },
            { id: '6', title: '2048', category: 'Puzzle', url: 'https://play2048.co/', thumbnail: 'https://images.unsplash.com/photo-1611996575749-79a3a250f948?w=400&h=300&fit=crop', color: '#ff6b9d' },
            { id: '7', title: 'Minesweeper', category: 'Logic', url: 'https://minesweeper.online/', thumbnail: 'https://images.unsplash.com/photo-1526374965328-7f61d4dc18c5?w=400&h=300&fit=crop', color: '#66ddff' },
            { id: '8', title: 'Pac-Man', category: 'Arcade', url: 'https://www.google.com/logos/2010/pacman10-i.html', thumbnail: 'https://images.unsplash.com/photo-1578303512597-81e6cc155b3e?w=400&h=300&fit=crop', color: '#ffdd00' },
        ];

        // Supabase Service Functions
        const SupabaseService = {
            // Sign in with Google
            signInWithGoogle: async () => {
                try {
                    const { data, error } = await supabase.auth.signInWithOAuth({
                        provider: 'google',
                        options: {
                            queryParams: {
                                hd: 'kcpupils.org' // Restrict to kcpupils.org domain
                            },
                            redirectTo: window.location.origin
                        }
                    });
                    
                    if (error) throw error;
                    return data;
                } catch (error) {
                    console.error('Google sign in error:', error);
                    throw error;
                }
            },

            // Get current session
            getSession: async () => {
                const { data: { session }, error } = await supabase.auth.getSession();
                if (error) throw error;
                return session;
            },

            // Sign out
            signOut: async () => {
                const { error } = await supabase.auth.signOut();
                if (error) throw error;
            },

            // Create or update user profile
            createUserProfile: async (user) => {
                try {
                    const { data: existingUser, error: fetchError } = await supabase
                        .from('users')
                        .select('*')
                        .eq('id', user.id)
                        .single();

                    if (fetchError && fetchError.code !== 'PGRST116') {
                        console.error('Error fetching user:', fetchError);
                    }

                    if (!existingUser) {
                        const { error: insertError } = await supabase
                            .from('users')
                            .insert({
                                id: user.id,
                                email: user.email,
                                display_name: user.user_metadata.full_name,
                                photo_url: user.user_metadata.avatar_url,
                                status: 'online',
                                stats: {
                                    games_played: 0,
                                    total_time: 0,
                                    achievements: 0
                                },
                                created_at: new Date().toISOString()
                            });

                        if (insertError) throw insertError;
                    } else {
                        // Update user status
                        const { error: updateError } = await supabase
                            .from('users')
                            .update({
                                status: 'online',
                                last_seen: new Date().toISOString()
                            })
                            .eq('id', user.id);

                        if (updateError) throw updateError;
                    }
                } catch (error) {
                    console.error('Error creating/updating user profile:', error);
                    throw error;
                }
            },

            // Update user status
            updateUserStatus: async (userId, status, currentGame = null) => {
                try {
                    const { error } = await supabase
                        .from('users')
                        .update({
                            status,
                            current_game: currentGame,
                            last_seen: new Date().toISOString()
                        })
                        .eq('id', userId);

                    if (error) throw error;
                } catch (error) {
                    console.error('Error updating user status:', error);
                    throw error;
                }
            },

            // Get friends list
            getFriends: async (userId) => {
                try {
                    const { data: friendships, error: friendsError } = await supabase
                        .from('friends')
                        .select('friend_id')
                        .eq('user_id', userId);

                    if (friendsError) throw friendsError;

                    if (!friendships || friendships.length === 0) return [];

                    const friendIds = friendships.map(f => f.friend_id);
                    
                    const { data: friends, error: usersError } = await supabase
                        .from('users')
                        .select('*')
                        .in('id', friendIds);

                    if (usersError) throw usersError;

                    return friends.map(friend => ({
                        id: friend.id,
                        displayName: friend.display_name,
                        email: friend.email,
                        photoURL: friend.photo_url,
                        status: friend.status,
                        currentGame: friend.current_game,
                        stats: friend.stats
                    }));
                } catch (error) {
                    console.error('Error getting friends:', error);
                    return [];
                }
            },

            // Add friend
            addFriend: async (currentUserId, friendEmail) => {
                try {
                    // Find user by email
                    const { data: friendUser, error: findError } = await supabase
                        .from('users')
                        .select('*')
                        .eq('email', friendEmail)
                        .single();

                    if (findError) throw new Error('User not found');

                    if (friendUser.id === currentUserId) {
                        throw new Error('Cannot add yourself as a friend');
                    }

                    // Check if already friends
                    const { data: existingFriendship, error: checkError } = await supabase
                        .from('friends')
                        .select('*')
                        .eq('user_id', currentUserId)
                        .eq('friend_id', friendUser.id)
                        .single();

                    if (!checkError && existingFriendship) {
                        throw new Error('Already friends');
                    }

                    // Add friendship (bidirectional)
                    const { error: addError } = await supabase
                        .from('friends')
                        .insert([
                            {
                                user_id: currentUserId,
                                friend_id: friendUser.id,
                                created_at: new Date().toISOString()
                            },
                            {
                                user_id: friendUser.id,
                                friend_id: currentUserId,
                                created_at: new Date().toISOString()
                            }
                        ]);

                    if (addError) throw addError;

                    return {
                        id: friendUser.id,
                        displayName: friendUser.display_name,
                        email: friendUser.email,
                        photoURL: friendUser.photo_url,
                        status: friendUser.status,
                        currentGame: friendUser.current_game,
                        stats: friendUser.stats
                    };
                } catch (error) {
                    console.error('Error adding friend:', error);
                    throw error;
                }
            },

            // Get or create conversation
            getOrCreateConversation: async (user1Id, user2Id) => {
                try {
                    // Query for existing conversation
                    const { data: existingConvos, error: findError } = await supabase
                        .from('conversations')
                        .select('*')
                        .contains('participants', [user1Id, user2Id]);

                    if (findError) throw findError;

                    let conversationId = null;
                    if (existingConvos && existingConvos.length > 0) {
                        conversationId = existingConvos[0].id;
                    } else {
                        // Create new conversation
                        const { data: newConvo, error: createError } = await supabase
                            .from('conversations')
                            .insert({
                                participants: [user1Id, user2Id],
                                last_message: null,
                                last_message_time: null,
                                created_at: new Date().toISOString()
                            })
                            .select()
                            .single();

                        if (createError) throw createError;
                        conversationId = newConvo.id;
                    }

                    return conversationId;
                } catch (error) {
                    console.error('Error getting/creating conversation:', error);
                    throw error;
                }
            },

            // Get conversations
            getConversations: async (userId) => {
                try {
                    const { data: conversations, error } = await supabase
                        .from('conversations')
                        .select('*')
                        .contains('participants', [userId])
                        .order('last_message_time', { ascending: false });

                    if (error) throw error;

                    if (!conversations) return [];

                    // Get friend details for each conversation
                    const conversationsWithDetails = await Promise.all(
                        conversations.map(async (conv) => {
                            const otherUserId = conv.participants.find(id => id !== userId);
                            const { data: friend } = await supabase
                                .from('users')
                                .select('*')
                                .eq('id', otherUserId)
                                .single();

                            return {
                                id: conv.id,
                                friendId: otherUserId,
                                friendName: friend?.display_name || 'Unknown',
                                friendAvatar: friend?.photo_url || '',
                                friendStatus: friend?.status || 'offline',
                                lastMessage: conv.last_message || '',
                                timestamp: conv.last_message_time ? new Date(conv.last_message_time) : new Date(),
                                unread: 0
                            };
                        })
                    );

                    return conversationsWithDetails;
                } catch (error) {
                    console.error('Error getting conversations:', error);
                    return [];
                }
            },

            // Get messages
            getMessages: async (conversationId) => {
                try {
                    const { data: messages, error } = await supabase
                        .from('messages')
                        .select('*')
                        .eq('conversation_id', conversationId)
                        .order('created_at', { ascending: true })
                        .limit(100);

                    if (error) throw error;

                    return messages.map(msg => ({
                        id: msg.id,
                        senderId: msg.sender_id,
                        text: msg.content,
                        gameInvite: msg.game_invite,
                        timestamp: new Date(msg.created_at)
                    }));
                } catch (error) {
                    console.error('Error getting messages:', error);
                    return [];
                }
            },

            // Send message
            sendMessage: async (conversationId, senderId, text, gameInvite = null) => {
                try {
                    // Insert message
                    const { error: messageError } = await supabase
                        .from('messages')
                        .insert({
                            conversation_id: conversationId,
                            sender_id: senderId,
                            content: text,
                            game_invite: gameInvite,
                            created_at: new Date().toISOString()
                        });

                    if (messageError) throw messageError;

                    // Update conversation
                    const { error: convError } = await supabase
                        .from('conversations')
                        .update({
                            last_message: text,
                            last_message_time: new Date().toISOString()
                        })
                        .eq('id', conversationId);

                    if (convError) throw convError;
                } catch (error) {
                    console.error('Error sending message:', error);
                    throw error;
                }
            },

            // Subscribe to real-time messages
            subscribeToMessages: (conversationId, callback) => {
                const subscription = supabase
                    .channel(`messages:${conversationId}`)
                    .on('postgres_changes', {
                        event: 'INSERT',
                        schema: 'public',
                        table: 'messages',
                        filter: `conversation_id=eq.${conversationId}`
                    }, (payload) => {
                        const newMessage = {
                            id: payload.new.id,
                            senderId: payload.new.sender_id,
                            text: payload.new.content,
                            gameInvite: payload.new.game_invite,
                            timestamp: new Date(payload.new.created_at)
                        };
                        callback(newMessage);
                    })
                    .subscribe();

                return () => {
                    supabase.removeChannel(subscription);
                };
            },

            // Subscribe to user status changes
            subscribeToUserStatus: (callback) => {
                const subscription = supabase
                    .channel('user-status')
                    .on('postgres_changes', {
                        event: 'UPDATE',
                        schema: 'public',
                        table: 'users'
                    }, (payload) => {
                        callback(payload.new);
                    })
                    .subscribe();

                return () => {
                    supabase.removeChannel(subscription);
                };
            },

            // Increment game played stat
            incrementGamePlayed: async (userId) => {
                try {
                    // First get current value
                    const { data: user, error: fetchError } = await supabase
                        .from('users')
                        .select('stats')
                        .eq('id', userId)
                        .single();

                    if (fetchError) throw fetchError;

                    const newStats = {
                        ...user.stats,
                        games_played: (user.stats.games_played || 0) + 1
                    };

                    const { error: updateError } = await supabase
                        .from('users')
                        .update({
                            stats: newStats
                        })
                        .eq('id', userId);

                    if (updateError) throw updateError;
                } catch (error) {
                    console.error('Error incrementing game played:', error);
                }
            }
        };

        // Login Screen Component
        function LoginScreen({ onLoginSuccess }) {
            const [loading, setLoading] = useState(false);
            const [error, setError] = useState('');

            const handleGoogleSignIn = async () => {
                setLoading(true);
                setError('');
                try {
                    await SupabaseService.signInWithGoogle();
                    // The actual login will be handled by the auth state change listener
                } catch (err) {
                    console.error('Login error:', err);
                    if (err.message === 'Popup window closed') {
                        setError('Sign-in was cancelled');
                    } else {
                        setError('Failed to sign in. Please try again.');
                    }
                } finally {
                    setLoading(false);
                }
            };

            return (
                <div style={{
                    position: 'fixed',
                    inset: 0,
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'center',
                    background: 'var(--bg-primary)',
                    animation: 'fadeIn 0.6s ease-out'
                }}>
                    <div style={{
                        background: 'var(--bg-secondary)',
                        border: '1px solid var(--border-color)',
                        borderRadius: '24px',
                        padding: '60px 50px',
                        maxWidth: '440px',
                        width: '90%',
                        textAlign: 'center',
                        boxShadow: 'var(--shadow-glow)'
                    }}>
                        <div style={{
                            width: '80px',
                            height: '80px',
                            margin: '0 auto 30px',
                            background: 'linear-gradient(135deg, var(--accent-primary), var(--accent-secondary))',
                            borderRadius: '20px',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'center',
                            fontSize: '40px',
                            animation: 'float 3s ease-in-out infinite'
                        }}>
                            ðŸŽ®
                        </div>

                        <h1 style={{
                            fontSize: '32px',
                            fontWeight: '800',
                            marginBottom: '12px',
                            background: 'linear-gradient(135deg, var(--accent-primary), var(--accent-secondary))',
                            WebkitBackgroundClip: 'text',
                            WebkitTextFillColor: 'transparent',
                            backgroundClip: 'text'
                        }}>
                            Maths Support
                        </h1>

                        <p style={{
                            color: 'var(--text-secondary)',
                            marginBottom: '40px',
                            fontSize: '15px'
                        }}>
                            Sign in with your @kcpupils.org account to access games, chat with friends, and track your progress
                        </p>

                        <button
                            onClick={handleGoogleSignIn}
                            disabled={loading}
                            style={{
                                width: '100%',
                                padding: '16px',
                                background: '#fff',
                                color: '#000',
                                border: 'none',
                                borderRadius: '12px',
                                fontSize: '16px',
                                fontWeight: '700',
                                cursor: loading ? 'not-allowed' : 'pointer',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                gap: '12px',
                                transition: 'all 0.3s ease',
                                opacity: loading ? 0.6 : 1
                            }}
                            onMouseEnter={(e) => {
                                if (!loading) {
                                    e.target.style.transform = 'translateY(-2px)';
                                    e.target.style.boxShadow = '0 8px 24px rgba(255,255,255,0.2)';
                                }
                            }}
                            onMouseLeave={(e) => {
                                e.target.style.transform = 'translateY(0)';
                                e.target.style.boxShadow = 'none';
                            }}
                        >
                            {loading ? (
                                <>
                                    <div style={{ 
                                        width: '20px', 
                                        height: '20px', 
                                        border: '3px solid #ddd', 
                                        borderTop: '3px solid #000',
                                        borderRadius: '50%',
                                        animation: 'spin 1s linear infinite'
                                    }} />
                                    <span>Signing in...</span>
                                </>
                            ) : (
                                <>
                                    <svg width="20" height="20" viewBox="0 0 24 24">
                                        <path fill="#4285F4" d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"/>
                                        <path fill="#34A853" d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"/>
                                        <path fill="#FBBC05" d="M5.84 14.09c-.22-.66-.35-1.36-.35-2.09s.13-1.43.35-2.09V7.07H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.93l2.85-2.22.81-.62z"/>
                                        <path fill="#EA4335" d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.07l3.66 2.84c.87-2.6 3.3-4.53 6.16-4.53z"/>
                                    </svg>
                                    <span>Continue with Google</span>
                                </>
                            )}
                        </button>

                        {error && (
                            <div style={{
                                marginTop: '20px',
                                padding: '12px',
                                background: 'rgba(255, 68, 102, 0.1)',
                                border: '1px solid var(--accent-danger)',
                                borderRadius: '8px',
                                color: 'var(--accent-danger)',
                                fontSize: '14px'
                            }}>
                                {error}
                            </div>
                        )}

                        <div style={{
                            marginTop: '30px',
                            fontSize: '13px',
                            color: 'var(--text-secondary)',
                            lineHeight: '1.6'
                        }}>
                            By signing in, you agree to our Terms of Service and Privacy Policy
                        </div>
                    </div>
                </div>
            );
        }

        // Main App Component
        function App() {
            const [user, setUser] = useState(null);
            const [loading, setLoading] = useState(true);
            const [activeSection, setActiveSection] = useState('games');
            const [friends, setFriends] = useState([]);
            const [conversations, setConversations] = useState([]);
            const [activeConversation, setActiveConversation] = useState(null);
            const [messages, setMessages] = useState([]);
            const [currentGame, setCurrentGame] = useState(null);
            const [searchQuery, setSearchQuery] = useState('');
            const [showAddFriend, setShowAddFriend] = useState(false);
            const [showGameInvite, setShowGameInvite] = useState(false);
            const [selectedFriend, setSelectedFriend] = useState(null);

            const unsubscribeRefs = useRef([]);

            useEffect(() => {
                // Check for existing session
                const checkSession = async () => {
                    try {
                        const session = await SupabaseService.getSession();
                        if (session?.user) {
                            // Verify email domain
                            if (!session.user.email.endsWith('@kcpupils.org')) {
                                await SupabaseService.signOut();
                                setLoading(false);
                                return;
                            }
                            
                            setUser(session.user);
                            await SupabaseService.createUserProfile(session.user);
                            setupListeners(session.user);
                        }
                    } catch (error) {
                        console.error('Session check error:', error);
                    } finally {
                        setLoading(false);
                    }
                };

                checkSession();

                // Listen for auth state changes
                const { data: { subscription } } = supabase.auth.onAuthStateChange(
                    async (event, session) => {
                        if (event === 'SIGNED_IN' && session?.user) {
                            if (!session.user.email.endsWith('@kcpupils.org')) {
                                await SupabaseService.signOut();
                                return;
                            }
                            
                            setUser(session.user);
                            await SupabaseService.createUserProfile(session.user);
                            setupListeners(session.user);
                        } else if (event === 'SIGNED_OUT') {
                            cleanupListeners();
                            setUser(null);
                            setFriends([]);
                            setConversations([]);
                            setActiveConversation(null);
                        }
                    }
                );

                return () => {
                    subscription.unsubscribe();
                    cleanupListeners();
                };
            }, []);

            const setupListeners = async (user) => {
                try {
                    // Load initial data
                    const [friendsData, conversationsData] = await Promise.all([
                        SupabaseService.getFriends(user.id),
                        SupabaseService.getConversations(user.id)
                    ]);
                    
                    setFriends(friendsData);
                    setConversations(conversationsData);

                    // Subscribe to user status changes
                    const statusUnsub = SupabaseService.subscribeToUserStatus((updatedUser) => {
                        setFriends(prev => prev.map(friend => 
                            friend.id === updatedUser.id 
                                ? { ...friend, status: updatedUser.status, currentGame: updatedUser.current_game }
                                : friend
                        ));
                        
                        setConversations(prev => prev.map(conv => 
                            conv.friendId === updatedUser.id
                                ? { ...conv, friendStatus: updatedUser.status }
                                : conv
                        ));
                    });
                    
                    unsubscribeRefs.current.push(statusUnsub);
                } catch (error) {
                    console.error('Error setting up listeners:', error);
                }
            };

            const cleanupListeners = () => {
                unsubscribeRefs.current.forEach(unsub => {
                    if (typeof unsub === 'function') unsub();
                });
                unsubscribeRefs.current = [];
            };

            useEffect(() => {
                if (activeConversation) {
                    // Load messages
                    const loadMessages = async () => {
                        const messages = await SupabaseService.getMessages(activeConversation.id);
                        setMessages(messages);
                    };
                    loadMessages();

                    // Subscribe to new messages
                    const messageUnsub = SupabaseService.subscribeToMessages(
                        activeConversation.id,
                        (newMessage) => {
                            setMessages(prev => [...prev, newMessage]);
                        }
                    );

                    return () => {
                        if (messageUnsub) messageUnsub();
                    };
                }
            }, [activeConversation]);

            useEffect(() => {
                const handleBeforeUnload = async () => {
                    if (user) {
                        await SupabaseService.updateUserStatus(user.id, 'offline');
                    }
                };

                window.addEventListener('beforeunload', handleBeforeUnload);
                return () => window.removeEventListener('beforeunload', handleBeforeUnload);
            }, [user]);

            const handleLogout = async () => {
                try {
                    if (user) {
                        await SupabaseService.updateUserStatus(user.id, 'offline');
                        await SupabaseService.signOut();
                    }
                    cleanupListeners();
                    setUser(null);
                    setActiveSection('games');
                    setFriends([]);
                    setConversations([]);
                } catch (error) {
                    console.error('Logout error:', error);
                }
            };

            const openConversation = async (conversation) => {
                setActiveConversation(conversation);
                setActiveSection('messages');
            };

            const sendMessage = async (text, gameInvite = null) => {
                if ((!text.trim() && !gameInvite) || !activeConversation || !user) return;

                try {
                    await SupabaseService.sendMessage(
                        activeConversation.id,
                        user.id,
                        text,
                        gameInvite
                    );
                } catch (error) {
                    console.error('Error sending message:', error);
                    alert('Failed to send message');
                }
            };

            const playGame = async (game) => {
                setCurrentGame(game);
                if (user) {
                    await SupabaseService.updateUserStatus(user.id, 'online', game.title);
                    await SupabaseService.incrementGamePlayed(user.id);
                }
            };

            const exitGame = async () => {
                setCurrentGame(null);
                if (user) {
                    await SupabaseService.updateUserStatus(user.id, 'online', null);
                }
            };

            const handleAddFriend = async (email) => {
                try {
                    const newFriend = await SupabaseService.addFriend(user.id, email);
                    setFriends(prev => [...prev, newFriend]);
                    setShowAddFriend(false);
                } catch (error) {
                    console.error('Error adding friend:', error);
                    alert(error.message);
                }
            };

            const handleMessageFriend = async (friend) => {
                try {
                    const conversationId = await SupabaseService.getOrCreateConversation(
                        user.id,
                        friend.id
                    );
                    
                    const conversation = {
                        id: conversationId,
                        friendId: friend.id,
                        friendName: friend.displayName,
                        friendAvatar: friend.photoURL,
                        friendStatus: friend.status,
                        lastMessage: '',
                        timestamp: new Date(),
                        unread: 0
                    };
                    
                    openConversation(conversation);
                    
                    // Update conversations list
                    setConversations(prev => [conversation, ...prev.filter(c => c.id !== conversationId)]);
                } catch (error) {
                    console.error('Error opening conversation:', error);
                }
            };

            const filteredGames = GAMES.filter(game => 
                game.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
                game.category.toLowerCase().includes(searchQuery.toLowerCase())
            );

            if (loading) {
                return (
                    <div style={{
                        position: 'fixed',
                        inset: 0,
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        background: 'var(--bg-primary)'
                    }}>
                        <div style={{
                            width: '50px',
                            height: '50px',
                            border: '4px solid var(--bg-secondary)',
                            borderTop: '4px solid var(--accent-primary)',
                            borderRadius: '50%',
                            animation: 'spin 1s linear infinite'
                        }} />
                    </div>
                );
            }

            if (!user) {
                return <LoginScreen onLoginSuccess={setUser} />;
            }

            if (currentGame) {
                return <GamePlayer game={currentGame} onExit={exitGame} />;
            }

            return (
                <div style={{ display: 'flex', height: '100vh' }}>
                    <Sidebar 
                        activeSection={activeSection}
                        onSectionChange={setActiveSection}
                        onLogout={handleLogout}
                    />

                    <MainContent
                        activeSection={activeSection}
                        user={user}
                        friends={friends}
                        conversations={conversations}
                        activeConversation={activeConversation}
                        messages={messages}
                        games={filteredGames}
                        searchQuery={searchQuery}
                        onSearchChange={setSearchQuery}
                        onPlayGame={playGame}
                        onOpenConversation={openConversation}
                        onSendMessage={sendMessage}
                        onShowGameInvite={(friend) => {
                            setSelectedFriend(friend);
                            setShowGameInvite(true);
                        }}
                    />

                    <FriendsPanel 
                        friends={friends}
                        onMessageFriend={handleMessageFriend}
                        onAddFriend={() => setShowAddFriend(true)}
                    />

                    {showAddFriend && (
                        <AddFriendModal
                            onClose={() => setShowAddFriend(false)}
                            onAddFriend={handleAddFriend}
                        />
                    )}

                    {showGameInvite && (
                        <GameInviteModal
                            games={GAMES}
                            friend={selectedFriend}
                            onClose={() => setShowGameInvite(false)}
                            onInvite={(game) => {
                                sendMessage(`Let's play ${game.title}!`, game);
                                setShowGameInvite(false);
                            }}
                        />
                    )}
                </div>
            );
        }

        // ... Rest of the components remain the same as in the original code ...
        // (Sidebar, MainContent, GamesSection, ProfileSection, MessagesSection, etc.)
        // Only the data fetching methods have been changed to use Supabase

        // IMPORTANT: You need to replace 'YOUR_SUPABASE_URL' and 'YOUR_SUPABASE_ANON_KEY' with your actual Supabase credentials

        // Render App
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
